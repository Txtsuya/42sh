
/*
** EPITECH PROJECT, 2025
** other
** File description:
** other
*/
#include "../../include/minishel.h"

static int is_space(char c)
{
    return (c <= ' ');
}

static int count_args_for_parentheses(char *input)
{
    int level = 0;
    int count = 0;
    int i = 0;
    int has_prev_char = 0;

    while (input[i] != '\0') {
        if (input[i] == '(')
            level++;
        else if (input[i] == ')')
            level--;
        else if (level == 0 && (input[i] == '|' || input[i] == '>' || input[i] == '<') || input[i] == '&') {
            // Séparateur trouvé à niveau 0
            if (has_prev_char)
                count++;  // Comptez l'argument avant le séparateur
            count++;      // Comptez le séparateur lui-même
            has_prev_char = 0;
            if ((input[i] == '>' && input[i+1] == '>') || 
                (input[i] == '<' && input[i+1] == '<') ||
                (input[i] == '&' && input[i+1] == '&') ||
                (input[i] == '|' && input[i+1] == '|'))
                i++;
        } else if (!is_space(input[i])) {
            has_prev_char = 1;
        }
        i++;
    }
    if (has_prev_char)
        count++;  // Dernier argument
    return count;
}

static char *copy_string_for_parentheses(char *input, int start, int end)
{
    char *result;
    int j = 0;
    
    // Ignorer les espaces au début et à la fin
    while (start < end && is_space(input[start]))
        start++;
    while (end > start && is_space(input[end - 1]))
        end--;
    
    if (start >= end)
        return NULL;
    
    result = malloc(sizeof(char) * (end - start + 1));
    if (!result)
        return NULL;
    
    for (int i = start; i < end; i++)
        result[j++] = input[i];
    result[j] = '\0';
    
    return result;
}

char **string_to_array_for_parentheses(char *input)
{
    int count = count_args_for_parentheses(input);
    char **array = malloc(sizeof(char *) * (count + 1));
    int index = 0;
    int start = 0;
    int level = 0;
    int i = 0;
    
    if (!array)
        return NULL;
    
    while (input[i] != '\0') {
        if (input[i] == '(')
            level++;
        else if (input[i] == ')')
            level--;
        else if (level == 0 && (input[i] == '|' || input[i] == '>' || input[i] == '<' || input[i] == '&')) {
            char *arg = copy_string_for_parentheses(input, start, i);
            if (arg != NULL) {
                array[index++] = arg;
            }
            if ((input[i] == '>' && input[i+1] == '>') || 
                (input[i] == '<' && input[i+1] == '<') ||
                (input[i] == '&' && input[i+1] == '&') ||
                (input[i] == '|' && input[i+1] == '|')) {
                array[index] = malloc(3 * sizeof(char));
                array[index][0] = input[i];
                array[index][1] = input[i+1];
                array[index][2] = '\0';
                i++;
            } else {
                array[index] = malloc(2 * sizeof(char));
                array[index][0] = input[i];
                array[index][1] = '\0';
            }
            index++;
            start = i + 1;
        }
        i++;
    }
    
    // Ajouter le dernier argument
    if (start < i) {
        char *arg = copy_string_for_parentheses(input, start, i);
        if (arg != NULL) {
            array[index++] = arg;
        }
    }
    
    array[index] = NULL;
    return array;
}

char *clean_parenthese_argv(char *cmd)
{
    int len;
    char *cleaned_cmd;
    
    // Check if cmd is valid
    if (!cmd)
        return NULL;
    
    len = my_strlen(cmd);
    
    // Check if string is long enough to have parentheses
    if (len < 2)
        return my_strdup(cmd); // Return a copy of the original string
    
    // Check if string starts with '(' and ends with ')'
    if (cmd[0] != '(' || cmd[len - 1] != ')')
        return my_strdup(cmd); // Return a copy if no parentheses to remove
    cleaned_cmd = malloc(sizeof(char) * (len - 1));
    if (!cleaned_cmd)
        return NULL;
    strncpy(cleaned_cmd, cmd + 1, len - 2);
    cleaned_cmd[len - 2] = '\0';
    return cleaned_cmd;
}
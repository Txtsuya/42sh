#!/usr/bin/env python3

import argparse
import os
import re
import shutil
import subprocess
import sys
from typing import List, Tuple, Dict

COLOR_RED = '\033[31m'
COLOR_GREEN = '\033[32m'
COLOR_YELLOW = '\033[33m'
COLOR_BLUE = '\033[34m'
COLOR_RESET = '\033[0m'

def print_header():
    print(f"""
{COLOR_BLUE}
╔═══════════════════════════════════════════════════════╗
║                  FUNCTION CHECKER                     ║
║           Check for unauthorized functions            ║
╚═══════════════════════════════════════════════════════╝
{COLOR_RESET}
    """)

def print_colored(message: str, color: str = COLOR_RESET):
    print(f"{color}{message}{COLOR_RESET}")

def print_error(message: str):
    print_colored(f"ERROR: {message}", COLOR_RED)

def print_warning(message: str):
    print_colored(f"WARNING: {message}", COLOR_YELLOW)

def print_success(message: str):
    print_colored(f"✓ {message}", COLOR_GREEN)

def print_info(message: str):
    print_colored(message, COLOR_BLUE)

def check_tool_exists(name: str) -> bool:
    if not shutil.which(name):
        print_error(f"Required tool '{name}' not found in PATH.")
        return False
    return True

def check_file_exists(file_path: str) -> bool:
    if not os.path.isfile(file_path):
        print_error(f"File '{file_path}' not found.")
        return False
    return True

def check_directory_exists(dir_path: str) -> bool:
    if not os.path.isdir(dir_path):
        print_error(f"Directory '{dir_path}' not found.")
        return False
    return True

def run_nm_command(binary_path: str) -> str:
    try:
        result = subprocess.run(
            ['nm', '-u', binary_path],
            capture_output=True, 
            text=True, 
            check=True
        )
        return result.stdout
    except subprocess.CalledProcessError as e:
        print_error(f"Error running nm: {e}")
        sys.exit(1)
    except Exception as e:
        print_error(f"Unexpected error: {e}")
        sys.exit(1)

def parse_nm_output(nm_output: str) -> List[str]:
    functions = []
    
    for line in nm_output.splitlines():
        if ' U ' in line:
            function_name = line.strip().split(' ')[-1]
            
            if not function_name.startswith('__'):
                clean_name = function_name.split('@')[0]
                functions.append(clean_name)
    
    return sorted(list(set(functions)))

def extract_functions(binary_path: str) -> List[str]:
    nm_output = run_nm_command(binary_path)
    return parse_nm_output(nm_output)

def read_file_lines(file_path: str) -> List[str]:
    try:
        with open(file_path, 'r') as f:
            return f.readlines()
    except FileNotFoundError:
        print_error(f"File '{file_path}' not found.")
        sys.exit(1)
    except Exception as e:
        print_error(f"Error reading file '{file_path}': {e}")
        sys.exit(1)

def load_authorized_functions(file_path: str) -> List[str]:
    lines = read_file_lines(file_path)
    return [line.strip() for line in lines if line.strip()]

def is_function_authorized(func_name: str, authorized_patterns: List[str]) -> bool:
    return any(re.match(pattern, func_name) for pattern in authorized_patterns)

def find_unauthorized_functions(all_functions: List[str], authorized_list: List[str]) -> List[str]:
    unauthorized = []
    
    for func in all_functions:
        if not is_function_authorized(func, authorized_list):
            unauthorized.append(func)
    
    return unauthorized

def get_source_files(source_dir: str) -> List[str]:
    c_files = []
    
    for root, _, files in os.walk(source_dir):
        for file in files:
            if file.endswith(('.c', '.h')):
                c_files.append(os.path.join(root, file))
    
    return c_files

def get_function_call_patterns(func_name: str) -> List[str]:
    return [
        fr'\b{re.escape(func_name)}\s*\(',
        fr'\b{re.escape(func_name)}\s*\)\s*\(',
    ]

def check_file_for_function_calls(file_path: str, unauthorized_funcs: List[str]) -> List[Tuple[str, int]]:
    occurrences = []
    
    try:
        with open(file_path, 'r', errors='ignore') as f:
            content = f.readlines()
        
        for line_num, line in enumerate(content, 1):
            for func in unauthorized_funcs:
                for pattern in get_function_call_patterns(func):
                    if re.search(pattern, line):
                        occurrences.append((func, line_num))
    except Exception as e:
        print_warning(f"Could not analyze {file_path}: {e}")
    
    return occurrences

def check_source_files(unauthorized_funcs: List[str], source_dir: str) -> Dict[str, List[Tuple[str, int]]]:
    if not source_dir or not os.path.isdir(source_dir):
        return {}
    
    source_files = get_source_files(source_dir)
    
    file_occurrences = {}
    for file_path in source_files:
        occurrences = check_file_for_function_calls(file_path, unauthorized_funcs)
        if occurrences:
            file_occurrences[file_path] = occurrences
    
    return file_occurrences

def print_function_list(functions: List[str], verbose: bool = False):
    if verbose:
        for func in functions:
            print(f"  - {func}")

def print_unauthorized_calls(file_occurrences: Dict[str, List[Tuple[str, int]]]):
    if not file_occurrences:
        print_warning("Could not locate unauthorized calls in source files.")
        return
    
    print_colored("\nFound unauthorized calls in these locations:", COLOR_YELLOW)
    
    for file_path, occurrences in file_occurrences.items():
        rel_path = os.path.relpath(file_path)
        print_info(f"\nIn file: {rel_path}")
        
        for func, line_num in occurrences:
            print(f"  Line {line_num}: unauthorized call to {COLOR_RED}{func}{COLOR_RESET}")

def parse_arguments():
    parser = argparse.ArgumentParser(description='Check for unauthorized function calls in a binary.')
    parser.add_argument('binary', help='Path to the binary to analyze')
    parser.add_argument(
        '-a', '--auth', 
        dest='auth_file', 
        help='Path to the file containing authorized functions (default: authorized_functions.txt)',
        default='authorized_functions.txt'
    )
    parser.add_argument(
        '-s', '--source', 
        dest='source_dir',
        help='Path to source directory for locating unauthorized calls in source files'
    )
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')

    return parser.parse_args()

def check_prerequisites(args):
    if not check_tool_exists('nm'):
        print_error("Please install 'nm' (usually part of binutils package).")
        return False

    if not check_file_exists(args.binary):
        return False

    return True

def main():
    args = parse_arguments()
    print_header()
    
    if not check_prerequisites(args):
        sys.exit(1)
    
    print(f"Analyzing binary: {COLOR_BLUE}{args.binary}{COLOR_RESET}")
    print(f"Using authorized functions from: {COLOR_BLUE}{args.auth_file}{COLOR_RESET}")
    
    all_functions = extract_functions(args.binary)
    if args.verbose:
        print_info(f"\nFound {len(all_functions)} external function calls:")
        print_function_list(all_functions, args.verbose)
    else:
        print(f"Found {len(all_functions)} external function calls.")
    
    authorized_list = load_authorized_functions(args.auth_file)
    if args.verbose:
        print_info(f"\nLoaded {len(authorized_list)} authorized function patterns.")
    
    unauthorized = find_unauthorized_functions(all_functions, authorized_list)
    
    if not unauthorized:
        print_success("\nNo unauthorized functions found!")
        return 0
    else:
        print_colored(f"\n✗ Found {len(unauthorized)} unauthorized function(s):", COLOR_RED)
        print_function_list(unauthorized, verbose=True)
        
        if args.source_dir:
            print_info("\nSearching for unauthorized calls in source files...")
            file_occurrences = check_source_files(unauthorized, args.source_dir)
            print_unauthorized_calls(file_occurrences)
                
        return 1

exit_code = main()
sys.exit(exit_code)